
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Maze</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #111; 
            color: #fff; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            overflow: hidden; 
        }
        #ui { 
            position: absolute; 
            top: 20px; 
            text-align: center; 
            z-index: 10; 
            width: 100%;
            pointer-events: none;
        }
        canvas { 
            background: #fff; 
            display: block; 
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }
        .stats { font-size: 2em; font-weight: bold; color: #3498db; text-shadow: 2px 2px #000; }
        #status { font-size: 1.2em; color: #ccc; }
        #hp-bar { 
            width: 400px; 
            height: 20px; 
            background: rgba(51, 51, 51, 0.8); 
            margin: 10px auto; 
            display: none; 
            border-radius: 10px; 
            border: 2px solid #555; 
            overflow: hidden; 
        }
        #hp-fill { width: 100%; height: 100%; background: #e74c3c; transition: width 0.1s; }
    </style>
</head>
<body>

<div id="ui">
    <div id="lvl-name" class="stats">LEVEL 1</div>
    <div id="status">WASD to Move | SHIFT to Run | SPACE to Attack</div>
    <div id="hp-bar"><div id="hp-fill"></div></div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Set Canvas to Fullscreen
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const TILE = 60; // Larger tiles for better visibility
let currentLevel = 1;
let frame = 0;
const keys = {};

const player = { x: 100, y: 100, speed: 4, dir: 1, state: 'idle' };
const hunter = { x: 0, y: 0, speed: 2.2, active: false, dir: 1, state: 'idle' };
const queen = { x: 0, y: 0, speed: 3, active: false, hp: 100, vx: 1, vy: 1 };
const wolf = { x: 0, y: 0, speed: 4.5, active: false, hp: 200, state: 'idle', jump: 0 };

// Map generation helper: 1=Wall, 2=Exit, 0=Path
// I have ensured these are all simple "hallway" or "open room" styles to prevent blocking.
const getMap = (lvl) => {
    const cols = Math.ceil(canvas.width / TILE);
    const rows = Math.ceil(canvas.height / TILE);
    let map = Array.from({ length: rows }, () => Array(cols).fill(0));

    // Outer Walls
    for(let r=0; r<rows; r++) { map[r][0] = 1; map[r][cols-1] = 1; }
    for(let c=0; c<cols; c++) { map[0][c] = 1; map[rows-1][c] = 1; }

    // Level Specific Layouts (Fixed Pathing)
    if (lvl === 9) {
        // Serpentine layout: guaranteed open path
        for(let c=2; c < cols-2; c++) {
            map[Math.floor(rows/3)][c] = (c < cols-4) ? 1 : 0;
            map[Math.floor(rows*2/3)][c] = (c > 4) ? 1 : 0;
        }
    } else if (lvl !== 4 && lvl !== 13) {
        // Random obstacles that don't block center
        for(let i=0; i<15; i++) {
            let rx = Math.floor(Math.random()*(cols-4))+2;
            let ry = Math.floor(Math.random()*(rows-4))+2;
            if (Math.abs(rx - Math.floor(cols/2)) > 2) map[ry][rx] = 1;
        }
    }

    // Place Exit
    map[rows-2][cols-2] = 2;
    return map;
};

let currentMap = getMap(1);

function drawStickman(x, y, color, scale, isQueen = false, entity) {
    ctx.save();
    ctx.translate(x, y);
    ctx.strokeStyle = color;
    ctx.lineWidth = 4 * scale;
    ctx.lineCap = 'round';
    const legSwing = (entity.state !== 'idle') ? Math.sin(frame * 0.15) * 12 : 0;
    
    // Head
    ctx.beginPath(); ctx.arc(0, -25*scale, 10*scale, 0, Math.PI*2); ctx.stroke();
    // Body
    ctx.beginPath(); ctx.moveTo(0, -15*scale); ctx.lineTo(0, 15*scale);
    // Arms
    if (entity.state === 'fight') {
        ctx.moveTo(0, -5*scale); ctx.lineTo(30*scale*(entity.dir || 1), -5*scale);
    } else {
        ctx.moveTo(0, -5*scale); ctx.lineTo(-15*scale, 10*scale);
        ctx.moveTo(0, -5*scale); ctx.lineTo(15*scale, 10*scale);
    }
    // Legs
    ctx.moveTo(0, 15*scale); ctx.lineTo(legSwing*scale, 35*scale);
    ctx.moveTo(0, 15*scale); ctx.lineTo(-legSwing*scale, 35*scale);
    ctx.stroke();

    if (isQueen) {
        ctx.fillStyle = "gold";
        ctx.beginPath(); ctx.moveTo(-15, -45); ctx.lineTo(0, -65); ctx.lineTo(15, -45); ctx.fill();
    }
    ctx.restore();
}

function isWall(x, y) {
    const r = 15;
    const points = [[x-r, y-r], [x+r, y-r], [x-r, y+r], [x+r, y+r]];
    for (let p of points) {
        let gx = Math.floor(p[0] / TILE), gy = Math.floor(p[1] / TILE);
        if (gy < 0 || gy >= currentMap.length || gx < 0 || gx >= currentMap[0].length || currentMap[gy][gx] === 1) return true;
    }
    return false;
}

function initLevel(lvl) {
    currentLevel = lvl;
    currentMap = getMap(lvl);
    player.x = 100; player.y = 100;
    document.getElementById('lvl-name').innerText = "LEVEL " + lvl;
    document.getElementById('hp-bar').style.display = (lvl === 4 || lvl === 13) ? 'block' : 'none';

    hunter.active = (lvl === 3);
    if(hunter.active) { hunter.x = canvas.width - 100; hunter.y = canvas.height - 100; }
    
    queen.active = (lvl === 4);
    if(queen.active) { queen.x = canvas.width/2; queen.y = canvas.height/2; queen.hp = 100; }

    wolf.active = (lvl === 13);
    if(wolf.active) { wolf.x = canvas.width/2; wolf.y = canvas.height/2; wolf.hp = 200; }
}

function update() {
    frame++;
    let s = keys['shift'] ? player.speed * 1.8 : player.speed;
    let dx = 0, dy = 0;
    if (keys['w']) dy -= s; if (keys['s']) dy += s;
    if (keys['a']) { dx -= s; player.dir = -1; }
    if (keys['d']) { dx += s; player.dir = 1; }
    
    if (dx !== 0 && !isWall(player.x + dx, player.y)) player.x += dx;
    if (dy !== 0 && !isWall(player.x, player.y + dy)) player.y += dy;
    player.state = (dx !== 0 || dy !== 0) ? 'walk' : 'idle';
    if (keys[' ']) player.state = 'fight';

    if (hunter.active) {
        let hdx = player.x > hunter.x ? hunter.speed : -hunter.speed;
        let hdy = player.y > hunter.y ? hunter.speed : -hunter.speed;
        if (!isWall(hunter.x + hdx, hunter.y)) { hunter.x += hdx; hunter.dir = hdx > 0 ? 1 : -1; }
        if (!isWall(hunter.x, hunter.y + hdy)) hunter.y += hdy;
        if (Math.hypot(player.x - hunter.x, player.y - hunter.y) < 40) {
            alert("The Hunter caught you!"); initLevel(3);
        }
    }

    if (queen.active) {
        queen.x += queen.vx * queen.speed; queen.y += queen.vy * queen.speed;
        if (isWall(queen.x + queen.vx*20, queen.y + queen.vy*20)) { queen.vx *= -1; queen.vy *= -1; }
        if (player.state === 'fight' && Math.hypot(player.x - queen.x, player.y - queen.y) < 80) {
            queen.hp -= 0.5;
            document.getElementById('hp-fill').style.width = (queen.hp/100)*100 + "%";
            if (queen.hp <= 0) queen.active = false;
        }
    }

    if (wolf.active) {
        let dist = Math.hypot(player.x - wolf.x, player.y - wolf.y);
        if (frame % 60 < 30) {
            wolf.x += (player.x > wolf.x ? 1 : -1) * wolf.speed;
            wolf.y += (player.y > wolf.y ? 1 : -1) * wolf.speed;
            wolf.jump = 0;
        } else { wolf.jump = -30; }
        if (player.state === 'fight' && dist < 120) {
            wolf.hp -= 0.5;
            document.getElementById('hp-fill').style.width = (wolf.hp/200)*100 + "%";
            if (wolf.hp <= 0) wolf.active = false;
        }
        if (dist < 50) { alert("The Wolf shredded you!"); initLevel(13); }
    }

    const gx = Math.floor(player.x / TILE), gy = Math.floor(player.y / TILE);
    if (currentMap[gy] && currentMap[gy][gx] === 2) {
        if ((currentLevel === 4 && queen.active) || (currentLevel === 13 && wolf.active)) return;
        if (currentLevel < 13) initLevel(currentLevel + 1);
        else { alert("YOU SURVIVED THE GAUNTLET!"); location.reload(); }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let r = 0; r < currentMap.length; r++) {
        for (let c = 0; c < currentMap[r].length; c++) {
            if (currentMap[r][c] === 1) { ctx.fillStyle = '#2c3e50'; ctx.fillRect(c * TILE, r * TILE, TILE, TILE); }
            else if (currentMap[r][c] === 2) { ctx.fillStyle = '#2ecc71'; ctx.fillRect(c * TILE, r * TILE, TILE, TILE); }
        }
    }
    if (hunter.active) drawStickman(hunter.x, hunter.y, '#e74c3c', 1.2, false, hunter);
    if (queen.active) drawStickman(queen.x, queen.y, '#9b59b6', 2.5, true, queen);
    if (wolf.active) {
        ctx.fillStyle = "#555"; ctx.fillRect(wolf.x-50, wolf.y-30+wolf.jump, 100, 60);
        ctx.fillStyle = "red"; ctx.fillRect(wolf.x+30, wolf.y-20+wolf.jump, 10, 10);
    }
    drawStickman(player.x, player.y, '#3498db', 1, false, player);
    update();
    requestAnimationFrame(draw);
}

window.onkeydown = (e) => keys[e.key.toLowerCase()] = true;
window.onkeyup = (e) => keys[e.key.toLowerCase()] = false;
initLevel(1);
draw();
</script>
</body>
</html>
